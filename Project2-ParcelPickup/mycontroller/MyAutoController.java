package mycontroller;

import controller.CarController;
import swen30006.driving.Simulation;
import world.Car;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

import tiles.*;
import utilities.Coordinate;
import world.WorldSpatial;

public class MyAutoController extends CarController{		
		// How many minimum units the wall is away from the player.
		private int wallSensitivity = 1;

		// Car Speed to move at
		private final int CAR_MAX_SPEED = 1;
		
		// Navigator
		private Navigator navigator;
		
		// Different moving behaviour
		private IMovingStrategy movingStrategy;
		
		// Should the car stay on ice tile
		private boolean stayOnIce = false;
		
		// Constructor
		public MyAutoController(Car car) {
			super(car);
			navigator = new Navigator(car);
			navigator.updateSeenTiles();
			
			movingStrategy = MovingStrategyFactory
					.getInstance()
					.createMovingStrategy(Simulation.toConserve());

		}
		
		
		@Override
		public void update() {
			
			Coordinate currentCoor = new Coordinate(getPosition());
			HashMap<Coordinate, MapTile> currentView = getView();
			
			// update previously seen tiles
			navigator.updateSeenTiles();
			
			
			// if the car is not moving
			if (getSpeed() < CAR_MAX_SPEED && (!stayOnIce)) {
				// set car to moving
				if (checkWallAhead(getOrientation(), currentView)) {
					applyReverseAcceleration();
				} else {
					applyForwardAcceleration();
				}
				return;
			} else if (stayOnIce && (currentView.get(currentCoor) instanceof HealthTrap)) {
				// suppose to stay on ice
				applyBrake();
			}
			
			// pick destination(s), can move towards parcel, goal or tile (explore)
			List<Coordinate> dest = 
					movingStrategy.pickDestination(navigator, 
							numParcels(), numParcelsFound());
			

			// compute paths to the destination(s)
			List<List<Coordinate>> paths = navigator.computePaths(dest, movingStrategy);
			
			if (paths.size() == 0) {
				// cannot find a path to the parcel, fall back to exploring
				dest = navigator.exploreMap();
				paths = navigator.computePaths(dest, movingStrategy);
			}
			
			if (paths.size() == 0) {
				// assume the car has not enough health to reach destination
				dest = navigator.containIceTiles();
				
				if (dest.size() == 0) {
					// no ice tiles
					System.exit(1);
				}
				
				// compute paths to ice tile(s)
				paths = navigator.computePaths(dest, movingStrategy);
				
				if (paths.size() == 0) { 
					// ice tiles unreachable
					System.exit(1);
				}
				stayOnIce = true;
			} else if (getSpeed() < CAR_MAX_SPEED) {
				// car is staying on ice and its has sufficient health now
				stayOnIce = false;
				applyForwardAcceleration();
			}
			
			
			// choose a path to a destination
			List<Coordinate> path = pickPath(paths);

			
			// move car along the path
			Coordinate currCoor = new Coordinate(getPosition());
			moveCar(currCoor, path);
			
		}

		/**
		 * Check if you have a wall in front of you!
		 * @param orientation the orientation we are in based on WorldSpatial
		 * @param currentView what the car can currently see
		 * @return
		 */
		private boolean checkWallAhead(WorldSpatial.Direction orientation, HashMap<Coordinate, MapTile> currentView){
			switch(orientation){
			case EAST:
				return checkEast(currentView);
			case NORTH:
				return checkNorth(currentView);
			case SOUTH:
				return checkSouth(currentView);
			case WEST:
				return checkWest(currentView);
			default:
				return false;
			}
		}
		
		/**
		 * Move the car along the path generated by breadth-first search
		 * @param from the coordinate of car current at
		 * @param path a list of coordinates in order to reach a destination
		 */
		private void moveCar(Coordinate from, List<Coordinate> path) {
			Coordinate to = path.get(0);
			int deltaX = to.x - from.x;
			int deltaY = to.y - from.y;
			
			WorldSpatial.Direction facing = getOrientation();
			int idx = Arrays.asList(Navigator.DIRECTIONS).indexOf(new Coordinate(deltaX, deltaY));
			
			WorldSpatial.Direction turnTo = WorldSpatial.Direction.values()[idx];
			
			switch(facing) {
			case NORTH:
				switch(turnTo) {
				case EAST:
					turnRight();
					break;
				case WEST:
					turnLeft();
					break;
				case SOUTH:
					if (!checkEast(getView())) {
						turnRight();
					} else if (!checkWest(getView())) {
						turnLeft();
					} else {
						applyReverseAcceleration();
						applyReverseAcceleration();
					}
					break;
				} 
				break;
			case SOUTH:
				switch(turnTo) {
				case EAST:
					turnLeft();
					break;
				case WEST:
					turnRight();
					break;
				case NORTH:
					if (!checkEast(getView())) {
						turnLeft();
					} else if (!checkWest(getView())) {
						turnRight();
					} else {
						applyReverseAcceleration();
						applyReverseAcceleration();
					}
					break;
				} 
				break;
			case EAST:
				switch(turnTo) {
				case NORTH:
					turnLeft();
					break;
				case SOUTH:
					turnRight();
					break;
				case WEST:
					if (!checkNorth(getView())) {
						turnLeft();
					} else if (!checkSouth(getView())) {
						turnRight();
					} else {
						applyReverseAcceleration();
					}
					break;
				} 
				break;
			case WEST:
				switch(turnTo) {
				case NORTH:
					turnRight();
					break;
				case SOUTH:
					turnLeft();
					break;
				case EAST:
					if (!checkNorth(getView())) {
						turnRight();
					} else if (!checkSouth(getView())) {
						turnLeft();
					} else {
						applyReverseAcceleration();
					}
					break;
				} 
				break;
			}
		}
		

		private List<Coordinate> pickPath(List<List<Coordinate>> paths) {
			// just return the path that requires less move
			Collections.sort(paths, new Comparator<List<Coordinate>>(){
			    public int compare(List<Coordinate> a1, List<Coordinate> a2) {
			        return a1.size() - a2.size();
			    }
			});
			return paths.get(0);
			
		}

		
		/**
		 * Method below just iterates through the list and check in the correct coordinates.
		 * i.e. Given your current position is 10,10
		 * checkEast will check up to wallSensitivity amount of tiles to the right.
		 * checkWest will check up to wallSensitivity amount of tiles to the left.
		 * checkNorth will check up to wallSensitivity amount of tiles to the top.
		 * checkSouth will check up to wallSensitivity amount of tiles below.
		 */
		public boolean checkEast(HashMap<Coordinate, MapTile> currentView){
			// Check tiles to my right
			Coordinate currentPosition = new Coordinate(getPosition());
			for(int i = 0; i <= wallSensitivity; i++){
				MapTile tile = currentView.get(new Coordinate(currentPosition.x+i, currentPosition.y));
				if(tile.isType(MapTile.Type.WALL)){
					return true;
				}
			}
			return false;
		}
		
		public boolean checkWest(HashMap<Coordinate,MapTile> currentView){
			// Check tiles to my left
			Coordinate currentPosition = new Coordinate(getPosition());
			for(int i = 0; i <= wallSensitivity; i++){
				MapTile tile = currentView.get(new Coordinate(currentPosition.x-i, currentPosition.y));
				if(tile.isType(MapTile.Type.WALL)){
					return true;
				}
			}
			return false;
		}
		
		public boolean checkNorth(HashMap<Coordinate,MapTile> currentView){
			// Check tiles to towards the top
			Coordinate currentPosition = new Coordinate(getPosition());
			for(int i = 0; i <= wallSensitivity; i++){
				MapTile tile = currentView.get(new Coordinate(currentPosition.x, currentPosition.y+i));
				if(tile.isType(MapTile.Type.WALL)){
					return true;
				}
			}
			return false;
		}
		
		public boolean checkSouth(HashMap<Coordinate,MapTile> currentView){
			// Check tiles towards the bottom
			Coordinate currentPosition = new Coordinate(getPosition());
			for(int i = 0; i <= wallSensitivity; i++){
				MapTile tile = currentView.get(new Coordinate(currentPosition.x, currentPosition.y-i));
				if(tile.isType(MapTile.Type.WALL)){
					return true;
				}
			}
			return false;
		}
		
	}
